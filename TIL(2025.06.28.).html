제목 : [내일배움캠프 data_6기 132일차] + 오늘의 학습 키워드

1. 오늘 학습 키워드: 
- [v] Daily scrum
- [] 코드카타 문제 풀이, 복습
- [] 컴활 1급 필기 공부
- [] 강의 및 복습(세션 강의 및 파이썬(판다스) 강의)
- [] 최종 프로젝트(데이터 EDA, 시각화, 대시보드)
- [] PYTHON 개인 공부
- [] 아티클 예습, 복습
- [] Daily scrum

2. 오늘 학습 한 내용을 나만의 언어로 정리하기
 - 

3. 코드카타
 - SQL: 
  - Japanese Cities' Attributes
select *
from city
where countrycode = 'JPN';
  - ,

 - PYTHON: 과제 진행하기
def solution(plans):
    answer = []
    for i in range(len(plans)):
        h, m = map(int, plans[i][1].split(':'))
        st = h * 60 + m
        plans[i][1] = st
        plans[i][2] = int(plans[i][2])
        
    plans.sort(key = lambda x : x[1])
    stack = []
    for i in range(len(plans)):
        if i == len(plans) - 1:
            stack.append(plans[i])
            break
            
        sub, st, t = plans[i]
        nsub, nst, nt = plans[i + 1]
        if st + t <= nst:
            answer.append(sub)
            temp_time = nst - (st + t)
            
            while temp_time != 0 and stack:
                tsub, tst, tt = stack.pop()
                if temp_time >= tt:
                    answer.append(tsub)
                    temp_time -= tt
                else:
                    stack.append([tsub, tst, tt - temp_time])
                    temp_time = 0
                    
        else:
            plans[i][2] = t - (nst - st)
            stack.append(plans[i])
            
    while stack:
        sub, st, tt = stack.pop()
        answer.append(sub)
        
    return answer
def possible(x, y, n, col):
    for i in range(x):
        # 같은 열에 위치하는지 or 같은 대각선에 위치하는지 확인
        if y == col[i] or abs(y - col[i]) == x - i:
            return False
    return True

def queen(x, n, col):
    
    # row가 끝까지 갔으면 성공!
    if x == n:
        return 1
    
    count = 0
    
    for y in range(n):
        # 다음 퀸을 놓을 수 있는 경우만 진행
        if possible(x, y, n, col):
            col[x] = y # x번째 row의 col index 저장 ex) col[0] = 20번째 행 2번째 col에 놓여져 있다.
            count += queen(x + 1, n, col) # row index 증가 후 호출
            
    return count

def solution(n):
    
    col = [0] * n
    
    # 0은 세로 축의 시작점
    # n은 맵의 크기
    # col은 row의 index를 담기 위한 리스트
    answer = queen(0, n, col)
    
    return answer

- 조이스틱
def solution(name):
    
    # 알파벳 변경 횟수(상하 이동)
    spell_move = 0
    
    # 커서 이동 횟수, 이름의 길이 -1(좌우 이동)
    cursor_move = len(name) - 1
    
    for i, spell in enumerate(name):
        # 알파벳 변경 횟수, 위아래 중 최소 이동 값(상하 이동)
        spell_move += min(ord(spell) - ord('A'), ord('Z') - ord(spell) + 1)
        
        # 해당 알파벳 다음부터 연속된 A 문자열 찾기
        next = i + 1
        while next < len(name) and name[next] == 'A':
            next += 1
            
        # 아래 3가지 경우 중 최소 이동 값으로 갱신
        # 1. 이전 커서 이동 값(초기값, 이름의 길이 - 1)
        # 2. 연속된 A의 왼쪽 시작
        # 3. 연속된 A의 오른쪽 시작
        cursor_move = min([cursor_move, 2 * i + len(name) - next, i + 2 * (len(name) -next)])
        
    # 조이스틱 조작 횟수 = 알파벳 변경 횟수(상하 이동) + 커서 이동 횟수(좌우 이동)
    return spell_move + cursor_move

4. 강의 듣기
 - 파이썬(EDA, 이상치 처리, 시각화) 강의

5. 아티클 예습, 복습 

6. 내일 학습 할 것은 무엇인지
 - SQL 코드카타(2025.06.29.까지)
 - PYTHON 알고리즘 코드카타(2025.06.29.까지)
 - 컴활 1급 필기 공부
 - SQL 개인 공부
 - PYTHON 개인 공부
 - 아티클 예습 및 복습
 - 최종 프로젝트(데이터 EDA, 시각화, 대시보드)
 - Daily Scrum

#내일배움캠프 #사전캠프 #TIL
