제목 : [내일배움캠프 data_6기 x일차] + 오늘의 학습 키워드

1. 오늘 학습 키워드: 
- [v] Daily scrum
- [] 코드카타 문제 풀이, 복습
- [] 컴활 1급 필기 공부
- [] 강의 및 복습
- [] PYTHON 개인 공부
- [] 아티클 예습, 복습
- [] Daily scrum

2. 오늘 학습 한 내용을 나만의 언어로 정리하기
 - 

3. 코드카타
 - SQL: 
  - Top Earners
select max(salary * months) as earnings, count(*)
from employee
group by salary * months
order by earnings desc
limit 1
;

  - Weather Observation Station 13
select round(sum(LAT_N),4)
from station
where 38.7880 < lat_n and lat_n < 137.2345

 - PYTHON:
  - 110 옮기기
def solution(s):
    # 110을 새로 넣어서 110이 나타나는 경우가 있을까요? 없습니다.
    # 0 110 0
    # 0 110 1
    # 1 110 0
    # 1 110 1
    # 따라서 문자열에서 110이 나타날 때마다 제거하는 식으로, 
    #문자열에서 나타나는 모든 110의 경우를 알아낼 수 있습니다.
    # 110을 모두 제거한 문자열과, 110의 개수를 우선 얻어보자.
    # 스택으로 해결하면 됩니다.
    answer = []
    for arr in s:
        stack, num110, i = [], 0, 0
        while i < len(arr):
            if arr[i] == '0':
                if len(stack) >= 2 and stack[-2] == '1' and stack[-1] == '1':
                    stack.pop()
                    stack.pop()
                    num110 += 1
                    i += 1
                else:
                    stack.append(arr[i])
                    i += 1
            else:
                stack.append(arr[i])
                i += 1
                
        # 뒤에서부터 읽어가면서, 처음 나타나는 0 뒤에 110들을 다 붙여줍니다.
        # 우선 stack을 뒤집고 0을 찾으면 뒤에서부터 몇 번째 (0-based)에 0이 처음으로 나오는지 셉니다.
        stack = ''.join(stack[::-1])
        idx = stack.find('0')
        
        if idx != -1:
            # 0이 있으면 뒤에 붙입니다.
            res = stack[:idx] + '011' * num110 + stack[idx:]
        else:
            # 0이 없으면 그냥 맨 앞에 붙입니다.
            res = stack + '011' * num110
        answer.append(''.join(res[::-1]))
        
    return answer

  - 미로 탈출 명령어
from collections import deque

def solution(n, m, x, y, r, c, k):
    answer = ''
    # 남은 거리 탐색 자주 해주어야 하므로 함수로 빼주기
    def manhattan(x1, y1):
        return abs(x1 - (r - 1)) + abs(y1 - (c - 1))
    
    # k가 최단 거리보다 작거나, 최단 거리 -k가 홀수라면 도착지에 k번만에 도착 불가
    if manhattan(x - 1, y - 1) > k or (manhattan(x - 1, y - 1) - k) % 2:
        return 'impossible'
    # 탐색 방향 사전순으로 - d l r u
    direct = {(1, 0):'d', (0, -1): 'l', (0, 1):'r', (-1, 0):'u'}
    q = deque()
    q.append((x - 1, y - 1, 0, ''))
    while q:
        si, sj, cnt, route = q.popleft()
        # 도착했는데 남은 거리가 홀수라면 도착지에 k만큼 오지 못한다!
        if (si, sj) == (r - 1, c - 1) and (k - cnt) % 2:
            return 'impossible'
        elif (si, sj) == (r - 1, c - 1) and cnt == k:
            return route
        for di, dj in direct:
            ni, nj = si + di, sj + dj
            if 0 <= ni < n and 0 <= nj < m:
                # 다음 이동 자리를 보는 것이므로 +1을 해주어야 함
                if manhattan(ni, nj) + cnt + 1 > k:
                    continue
                q.append((ni, nj, cnt + 1, route + direct[(di, dj)]))
                break
    
    return answer 


4. 강의 듣기
 - 스트림릿 강의

5. 아티클 예습, 복습 

6. 내일 학습 할 것은 무엇인지
 - SQL 코드카타(2025.08.09.까지)
 - PYTHON 알고리즘 코드카타(2025.08.09.까지)
 - 컴활 1급 필기 공부
 - SQL 개인 공부
 - PYTHON 개인 공부
 - 아티클 예습 및 복습
 - Daily Scrum

#내일배움캠프 #사전캠프 #TIL
